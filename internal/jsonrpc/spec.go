// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package jsonrpc

import "encoding/json"
import "errors"
import "fmt"
import "reflect"

// A discriminated union of all standard JSON-RPC and A2A-specific error types.
type A2AError interface{}

// A discriminated union representing all possible JSON-RPC 2.0 requests supported
// by the A2A specification.
type A2ARequest interface{}

// Defines a security scheme using an API key.
type APIKeySecurityScheme struct {
	// An optional description for the security scheme.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The location of the API key.
	In APIKeySecuritySchemeIn `json:"in" yaml:"in" mapstructure:"in"`

	// The name of the header, query, or cookie parameter to be used.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The type of the security scheme. Must be 'apiKey'.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type APIKeySecuritySchemeIn string

const APIKeySecuritySchemeInCookie APIKeySecuritySchemeIn = "cookie"
const APIKeySecuritySchemeInHeader APIKeySecuritySchemeIn = "header"
const APIKeySecuritySchemeInQuery APIKeySecuritySchemeIn = "query"

var enumValues_APIKeySecuritySchemeIn = []interface{}{
	"cookie",
	"header",
	"query",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *APIKeySecuritySchemeIn) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_APIKeySecuritySchemeIn {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_APIKeySecuritySchemeIn, v)
	}
	*j = APIKeySecuritySchemeIn(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *APIKeySecurityScheme) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["in"]; raw != nil && !ok {
		return fmt.Errorf("field in in APIKeySecurityScheme: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in APIKeySecurityScheme: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in APIKeySecurityScheme: required")
	}
	type Plain APIKeySecurityScheme
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = APIKeySecurityScheme(plain)
	return nil
}

// Defines optional capabilities supported by an agent.
type AgentCapabilities struct {
	// A list of protocol extensions supported by the agent.
	Extensions []AgentExtension `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// Indicates if the agent supports sending push notifications for asynchronous
	// task updates.
	PushNotifications *bool `json:"pushNotifications,omitempty" yaml:"pushNotifications,omitempty" mapstructure:"pushNotifications,omitempty"`

	// Indicates if the agent provides a history of state transitions for a task.
	StateTransitionHistory *bool `json:"stateTransitionHistory,omitempty" yaml:"stateTransitionHistory,omitempty" mapstructure:"stateTransitionHistory,omitempty"`

	// Indicates if the agent supports Server-Sent Events (SSE) for streaming
	// responses.
	Streaming *bool `json:"streaming,omitempty" yaml:"streaming,omitempty" mapstructure:"streaming,omitempty"`
}

// The AgentCard is a self-describing manifest for an agent. It provides essential
// metadata including the agent's identity, capabilities, skills, supported
// communication methods, and security requirements.
type AgentCard struct {
	// A list of additional supported interfaces (transport and URL combinations).
	// This allows agents to expose multiple transports, potentially at different
	// URLs.
	//
	// Best practices:
	// - SHOULD include all supported transports for completeness
	// - SHOULD include an entry matching the main 'url' and 'preferredTransport'
	// - MAY reuse URLs if multiple transports are available at the same endpoint
	// - MUST accurately declare the transport available at each URL
	//
	// Clients can select any interface from this list based on their transport
	// capabilities
	// and preferences. This enables transport negotiation and fallback scenarios.
	AdditionalInterfaces []AgentInterface `json:"additionalInterfaces,omitempty" yaml:"additionalInterfaces,omitempty" mapstructure:"additionalInterfaces,omitempty"`

	// A declaration of optional capabilities supported by the agent.
	Capabilities AgentCapabilities `json:"capabilities" yaml:"capabilities" mapstructure:"capabilities"`

	// Default set of supported input MIME types for all skills, which can be
	// overridden on a per-skill basis.
	DefaultInputModes []string `json:"defaultInputModes" yaml:"defaultInputModes" mapstructure:"defaultInputModes"`

	// Default set of supported output MIME types for all skills, which can be
	// overridden on a per-skill basis.
	DefaultOutputModes []string `json:"defaultOutputModes" yaml:"defaultOutputModes" mapstructure:"defaultOutputModes"`

	// A human-readable description of the agent, assisting users and other agents
	// in understanding its purpose.
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// An optional URL to the agent's documentation.
	DocumentationUrl *string `json:"documentationUrl,omitempty" yaml:"documentationUrl,omitempty" mapstructure:"documentationUrl,omitempty"`

	// An optional URL to an icon for the agent.
	IconUrl *string `json:"iconUrl,omitempty" yaml:"iconUrl,omitempty" mapstructure:"iconUrl,omitempty"`

	// A human-readable name for the agent.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The transport protocol for the preferred endpoint (the main 'url' field).
	// If not specified, defaults to 'JSONRPC'.
	//
	// IMPORTANT: The transport specified here MUST be available at the main 'url'.
	// This creates a binding between the main URL and its supported transport
	// protocol.
	// Clients should prefer this transport and URL combination when both are
	// supported.
	PreferredTransport string `json:"preferredTransport,omitempty" yaml:"preferredTransport,omitempty" mapstructure:"preferredTransport,omitempty"`

	// The version of the A2A protocol this agent supports.
	ProtocolVersion string `json:"protocolVersion" yaml:"protocolVersion" mapstructure:"protocolVersion"`

	// Information about the agent's service provider.
	Provider *AgentProvider `json:"provider,omitempty" yaml:"provider,omitempty" mapstructure:"provider,omitempty"`

	// A list of security requirement objects that apply to all agent interactions.
	// Each object
	// lists security schemes that can be used. Follows the OpenAPI 3.0 Security
	// Requirement Object.
	// This list can be seen as an OR of ANDs. Each object in the list describes one
	// possible
	// set of security requirements that must be present on a request. This allows
	// specifying,
	// for example, "callers must either use OAuth OR an API Key AND mTLS."
	Security []map[string][]string `json:"security,omitempty" yaml:"security,omitempty" mapstructure:"security,omitempty"`

	// A declaration of the security schemes available to authorize requests. The key
	// is the
	// scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
	SecuritySchemes map[string]interface{} `json:"securitySchemes,omitempty" yaml:"securitySchemes,omitempty" mapstructure:"securitySchemes,omitempty"`

	// JSON Web Signatures computed for this AgentCard.
	Signatures []AgentCardSignature `json:"signatures,omitempty" yaml:"signatures,omitempty" mapstructure:"signatures,omitempty"`

	// The set of skills, or distinct capabilities, that the agent can perform.
	Skills []AgentSkill `json:"skills" yaml:"skills" mapstructure:"skills"`

	// If true, the agent can provide an extended agent card with additional details
	// to authenticated users. Defaults to false.
	SupportsAuthenticatedExtendedCard *bool `json:"supportsAuthenticatedExtendedCard,omitempty" yaml:"supportsAuthenticatedExtendedCard,omitempty" mapstructure:"supportsAuthenticatedExtendedCard,omitempty"`

	// The preferred endpoint URL for interacting with the agent.
	// This URL MUST support the transport specified by 'preferredTransport'.
	Url string `json:"url" yaml:"url" mapstructure:"url"`

	// The agent's own version number. The format is defined by the provider.
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// AgentCardSignature represents a JWS signature of an AgentCard.
// This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
type AgentCardSignature struct {
	// The unprotected JWS header values.
	Header map[string]interface{} `json:"header,omitempty" yaml:"header,omitempty" mapstructure:"header,omitempty"`

	// The protected JWS header for the signature. This is a Base64url-encoded
	// JSON object, as per RFC 7515.
	Protected string `json:"protected" yaml:"protected" mapstructure:"protected"`

	// The computed signature, Base64url-encoded.
	Signature string `json:"signature" yaml:"signature" mapstructure:"signature"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentCardSignature) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["protected"]; raw != nil && !ok {
		return fmt.Errorf("field protected in AgentCardSignature: required")
	}
	if _, ok := raw["signature"]; raw != nil && !ok {
		return fmt.Errorf("field signature in AgentCardSignature: required")
	}
	type Plain AgentCardSignature
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentCardSignature(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentCard) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["capabilities"]; raw != nil && !ok {
		return fmt.Errorf("field capabilities in AgentCard: required")
	}
	if _, ok := raw["defaultInputModes"]; raw != nil && !ok {
		return fmt.Errorf("field defaultInputModes in AgentCard: required")
	}
	if _, ok := raw["defaultOutputModes"]; raw != nil && !ok {
		return fmt.Errorf("field defaultOutputModes in AgentCard: required")
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in AgentCard: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in AgentCard: required")
	}
	if _, ok := raw["skills"]; raw != nil && !ok {
		return fmt.Errorf("field skills in AgentCard: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in AgentCard: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in AgentCard: required")
	}
	type Plain AgentCard
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["preferredTransport"]; !ok || v == nil {
		plain.PreferredTransport = "JSONRPC"
	}
	if v, ok := raw["protocolVersion"]; !ok || v == nil {
		plain.ProtocolVersion = "0.3.0"
	}
	*j = AgentCard(plain)
	return nil
}

// A declaration of a protocol extension supported by an Agent.
type AgentExtension struct {
	// A human-readable description of how this agent uses the extension.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Optional, extension-specific configuration parameters.
	Params map[string]interface{} `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`

	// If true, the client must understand and comply with the extension's
	// requirements
	// to interact with the agent.
	Required *bool `json:"required,omitempty" yaml:"required,omitempty" mapstructure:"required,omitempty"`

	// The unique URI identifying the extension.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentExtension) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in AgentExtension: required")
	}
	type Plain AgentExtension
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentExtension(plain)
	return nil
}

// Declares a combination of a target URL and a transport protocol for interacting
// with the agent.
// This allows agents to expose the same functionality over multiple transport
// mechanisms.
type AgentInterface struct {
	// The transport protocol supported at this URL.
	Transport string `json:"transport" yaml:"transport" mapstructure:"transport"`

	// The URL where this interface is available. Must be a valid absolute HTTPS URL
	// in production.
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentInterface) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["transport"]; raw != nil && !ok {
		return fmt.Errorf("field transport in AgentInterface: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in AgentInterface: required")
	}
	type Plain AgentInterface
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentInterface(plain)
	return nil
}

// Represents the service provider of an agent.
type AgentProvider struct {
	// The name of the agent provider's organization.
	Organization string `json:"organization" yaml:"organization" mapstructure:"organization"`

	// A URL for the agent provider's website or relevant documentation.
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentProvider) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["organization"]; raw != nil && !ok {
		return fmt.Errorf("field organization in AgentProvider: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in AgentProvider: required")
	}
	type Plain AgentProvider
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentProvider(plain)
	return nil
}

// Represents a distinct capability or function that an agent can perform.
type AgentSkill struct {
	// A detailed description of the skill, intended to help clients or users
	// understand its purpose and functionality.
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// Example prompts or scenarios that this skill can handle. Provides a hint to
	// the client on how to use the skill.
	Examples []string `json:"examples,omitempty" yaml:"examples,omitempty" mapstructure:"examples,omitempty"`

	// A unique identifier for the agent's skill.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The set of supported input MIME types for this skill, overriding the agent's
	// defaults.
	InputModes []string `json:"inputModes,omitempty" yaml:"inputModes,omitempty" mapstructure:"inputModes,omitempty"`

	// A human-readable name for the skill.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The set of supported output MIME types for this skill, overriding the agent's
	// defaults.
	OutputModes []string `json:"outputModes,omitempty" yaml:"outputModes,omitempty" mapstructure:"outputModes,omitempty"`

	// Security schemes necessary for the agent to leverage this skill.
	// As in the overall AgentCard.security, this list represents a logical OR of
	// security
	// requirement objects. Each object is a set of security schemes that must be used
	// together
	// (a logical AND).
	Security []map[string][]string `json:"security,omitempty" yaml:"security,omitempty" mapstructure:"security,omitempty"`

	// A set of keywords describing the skill's capabilities.
	Tags []string `json:"tags" yaml:"tags" mapstructure:"tags"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentSkill) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in AgentSkill: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in AgentSkill: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in AgentSkill: required")
	}
	if _, ok := raw["tags"]; raw != nil && !ok {
		return fmt.Errorf("field tags in AgentSkill: required")
	}
	type Plain AgentSkill
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentSkill(plain)
	return nil
}

// Represents a file, data structure, or other resource generated by an agent
// during a task.
type Artifact struct {
	// A unique identifier for the artifact within the scope of the task.
	ArtifactId string `json:"artifactId" yaml:"artifactId" mapstructure:"artifactId"`

	// An optional, human-readable description of the artifact.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The URIs of extensions that are relevant to this artifact.
	Extensions []string `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// Optional metadata for extensions. The key is an extension-specific identifier.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// An optional, human-readable name for the artifact.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// An array of content parts that make up the artifact.
	Parts []ArtifactPartsElem `json:"parts" yaml:"parts" mapstructure:"parts"`
}

type ArtifactPartsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Artifact) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["artifactId"]; raw != nil && !ok {
		return fmt.Errorf("field artifactId in Artifact: required")
	}
	if _, ok := raw["parts"]; raw != nil && !ok {
		return fmt.Errorf("field parts in Artifact: required")
	}
	type Plain Artifact
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Artifact(plain)
	return nil
}

// An A2A-specific error indicating that the agent does not have an Authenticated
// Extended Card configured
type AuthenticatedExtendedCardNotConfiguredError struct {
	// The error code for when an authenticated extended card is not configured.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthenticatedExtendedCardNotConfiguredError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in AuthenticatedExtendedCardNotConfiguredError: required")
	}
	type Plain AuthenticatedExtendedCardNotConfiguredError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Authenticated Extended Card is not configured"
	}
	*j = AuthenticatedExtendedCardNotConfiguredError(plain)
	return nil
}

// Defines configuration details for the OAuth 2.0 Authorization Code flow.
type AuthorizationCodeOAuthFlow struct {
	// The authorization URL to be used for this flow.
	// This MUST be a URL and use TLS.
	AuthorizationUrl string `json:"authorizationUrl" yaml:"authorizationUrl" mapstructure:"authorizationUrl"`

	// The URL to be used for obtaining refresh tokens.
	// This MUST be a URL and use TLS.
	RefreshUrl *string `json:"refreshUrl,omitempty" yaml:"refreshUrl,omitempty" mapstructure:"refreshUrl,omitempty"`

	// The available scopes for the OAuth2 security scheme. A map between the scope
	// name and a short description for it.
	Scopes map[string]string `json:"scopes" yaml:"scopes" mapstructure:"scopes"`

	// The token URL to be used for this flow.
	// This MUST be a URL and use TLS.
	TokenUrl string `json:"tokenUrl" yaml:"tokenUrl" mapstructure:"tokenUrl"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizationCodeOAuthFlow) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["authorizationUrl"]; raw != nil && !ok {
		return fmt.Errorf("field authorizationUrl in AuthorizationCodeOAuthFlow: required")
	}
	if _, ok := raw["scopes"]; raw != nil && !ok {
		return fmt.Errorf("field scopes in AuthorizationCodeOAuthFlow: required")
	}
	if _, ok := raw["tokenUrl"]; raw != nil && !ok {
		return fmt.Errorf("field tokenUrl in AuthorizationCodeOAuthFlow: required")
	}
	type Plain AuthorizationCodeOAuthFlow
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AuthorizationCodeOAuthFlow(plain)
	return nil
}

// Represents a JSON-RPC request for the `tasks/cancel` method.
type CancelTaskRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'tasks/cancel'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameters identifying the task to cancel.
	Params TaskIdParams `json:"params" yaml:"params" mapstructure:"params"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CancelTaskRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in CancelTaskRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in CancelTaskRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in CancelTaskRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in CancelTaskRequest: required")
	}
	type Plain CancelTaskRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CancelTaskRequest(plain)
	return nil
}

// Represents a JSON-RPC response for the `tasks/cancel` method.
type CancelTaskResponse interface{}

// Represents a successful JSON-RPC response for the `tasks/cancel` method.
type CancelTaskSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The result, containing the final state of the canceled Task object.
	Result Task `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CancelTaskSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in CancelTaskSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in CancelTaskSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in CancelTaskSuccessResponse: required")
	}
	type Plain CancelTaskSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CancelTaskSuccessResponse(plain)
	return nil
}

// Defines configuration details for the OAuth 2.0 Client Credentials flow.
type ClientCredentialsOAuthFlow struct {
	// The URL to be used for obtaining refresh tokens. This MUST be a URL.
	RefreshUrl *string `json:"refreshUrl,omitempty" yaml:"refreshUrl,omitempty" mapstructure:"refreshUrl,omitempty"`

	// The available scopes for the OAuth2 security scheme. A map between the scope
	// name and a short description for it.
	Scopes map[string]string `json:"scopes" yaml:"scopes" mapstructure:"scopes"`

	// The token URL to be used for this flow. This MUST be a URL.
	TokenUrl string `json:"tokenUrl" yaml:"tokenUrl" mapstructure:"tokenUrl"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClientCredentialsOAuthFlow) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["scopes"]; raw != nil && !ok {
		return fmt.Errorf("field scopes in ClientCredentialsOAuthFlow: required")
	}
	if _, ok := raw["tokenUrl"]; raw != nil && !ok {
		return fmt.Errorf("field tokenUrl in ClientCredentialsOAuthFlow: required")
	}
	type Plain ClientCredentialsOAuthFlow
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClientCredentialsOAuthFlow(plain)
	return nil
}

// An A2A-specific error indicating an incompatibility between the requested
// content types and the agent's capabilities.
type ContentTypeNotSupportedError struct {
	// The error code for an unsupported content type.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContentTypeNotSupportedError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ContentTypeNotSupportedError: required")
	}
	type Plain ContentTypeNotSupportedError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Incompatible content types"
	}
	*j = ContentTypeNotSupportedError(plain)
	return nil
}

// Represents a structured data segment (e.g., JSON) within a message or artifact.
type DataPart struct {
	// The structured data content.
	Data map[string]interface{} `json:"data" yaml:"data" mapstructure:"data"`

	// The type of this part, used as a discriminator. Always 'data'.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Optional metadata associated with this part.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataPart) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in DataPart: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in DataPart: required")
	}
	type Plain DataPart
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DataPart(plain)
	return nil
}

// Defines parameters for deleting a specific push notification configuration for a
// task.
type DeleteTaskPushNotificationConfigParams struct {
	// The unique identifier of the task.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Optional metadata associated with the request.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The ID of the push notification configuration to delete.
	PushNotificationConfigId string `json:"pushNotificationConfigId" yaml:"pushNotificationConfigId" mapstructure:"pushNotificationConfigId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeleteTaskPushNotificationConfigParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in DeleteTaskPushNotificationConfigParams: required")
	}
	if _, ok := raw["pushNotificationConfigId"]; raw != nil && !ok {
		return fmt.Errorf("field pushNotificationConfigId in DeleteTaskPushNotificationConfigParams: required")
	}
	type Plain DeleteTaskPushNotificationConfigParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeleteTaskPushNotificationConfigParams(plain)
	return nil
}

// Represents a JSON-RPC request for the `tasks/pushNotificationConfig/delete`
// method.
type DeleteTaskPushNotificationConfigRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'tasks/pushNotificationConfig/delete'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameters identifying the push notification configuration to delete.
	Params DeleteTaskPushNotificationConfigParams `json:"params" yaml:"params" mapstructure:"params"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeleteTaskPushNotificationConfigRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in DeleteTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in DeleteTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in DeleteTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in DeleteTaskPushNotificationConfigRequest: required")
	}
	type Plain DeleteTaskPushNotificationConfigRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeleteTaskPushNotificationConfigRequest(plain)
	return nil
}

// Represents a JSON-RPC response for the `tasks/pushNotificationConfig/delete`
// method.
type DeleteTaskPushNotificationConfigResponse interface{}

// Represents a successful JSON-RPC response for the
// `tasks/pushNotificationConfig/delete` method.
type DeleteTaskPushNotificationConfigSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The result is null on successful deletion.
	Result interface{} `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeleteTaskPushNotificationConfigSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in DeleteTaskPushNotificationConfigSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in DeleteTaskPushNotificationConfigSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in DeleteTaskPushNotificationConfigSuccessResponse: required")
	}
	type Plain DeleteTaskPushNotificationConfigSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Result != nil {
		return fmt.Errorf("field %s: must be null", "result")
	}
	*j = DeleteTaskPushNotificationConfigSuccessResponse(plain)
	return nil
}

// Defines base properties for a file.
type FileBase struct {
	// The MIME type of the file (e.g., "application/pdf").
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// An optional name for the file (e.g., "document.pdf").
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Represents a file segment within a message or artifact. The file content can be
// provided either directly as bytes or as a URI.
type FilePart struct {
	// The file content, represented as either a URI or as base64-encoded bytes.
	File FilePartFile `json:"file" yaml:"file" mapstructure:"file"`

	// The type of this part, used as a discriminator. Always 'file'.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Optional metadata associated with this part.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Represents a file with its content provided directly as a base64-encoded string.
type FilePartFile struct {
	// The base64-encoded content of the file.
	Bytes string `json:"bytes" yaml:"bytes" mapstructure:"bytes"`

	// The MIME type of the file (e.g., "application/pdf").
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// An optional name for the file (e.g., "document.pdf").
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// A URL pointing to the file's content.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FilePartFile) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var filePartFile_0 FilePartFile_0
	var filePartFile_1 FilePartFile_1
	var errs []error
	if err := filePartFile_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := filePartFile_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 2 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain FilePartFile
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = FilePartFile(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FilePart) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["file"]; raw != nil && !ok {
		return fmt.Errorf("field file in FilePart: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in FilePart: required")
	}
	type Plain FilePart
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = FilePart(plain)
	return nil
}

// Represents a file with its content provided directly as a base64-encoded string.
type FileWithBytes struct {
	// The base64-encoded content of the file.
	Bytes string `json:"bytes" yaml:"bytes" mapstructure:"bytes"`

	// The MIME type of the file (e.g., "application/pdf").
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// An optional name for the file (e.g., "document.pdf").
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FileWithBytes) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bytes"]; raw != nil && !ok {
		return fmt.Errorf("field bytes in FileWithBytes: required")
	}
	type Plain FileWithBytes
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = FileWithBytes(plain)
	return nil
}

// Represents a file with its content located at a specific URI.
type FileWithUri struct {
	// The MIME type of the file (e.g., "application/pdf").
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// An optional name for the file (e.g., "document.pdf").
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// A URL pointing to the file's content.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FileWithUri) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in FileWithUri: required")
	}
	type Plain FileWithUri
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = FileWithUri(plain)
	return nil
}

// Represents a JSON-RPC request for the `agent/getAuthenticatedExtendedCard`
// method.
type GetAuthenticatedExtendedCardRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'agent/getAuthenticatedExtendedCard'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAuthenticatedExtendedCardRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetAuthenticatedExtendedCardRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in GetAuthenticatedExtendedCardRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in GetAuthenticatedExtendedCardRequest: required")
	}
	type Plain GetAuthenticatedExtendedCardRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetAuthenticatedExtendedCardRequest(plain)
	return nil
}

// Represents a JSON-RPC response for the `agent/getAuthenticatedExtendedCard`
// method.
type GetAuthenticatedExtendedCardResponse interface{}

// Represents a successful JSON-RPC response for the
// `agent/getAuthenticatedExtendedCard` method.
type GetAuthenticatedExtendedCardSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The result is an Agent Card object.
	Result AgentCard `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAuthenticatedExtendedCardSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetAuthenticatedExtendedCardSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in GetAuthenticatedExtendedCardSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in GetAuthenticatedExtendedCardSuccessResponse: required")
	}
	type Plain GetAuthenticatedExtendedCardSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetAuthenticatedExtendedCardSuccessResponse(plain)
	return nil
}

// Defines parameters for fetching a specific push notification configuration for a
// task.
type GetTaskPushNotificationConfigParams struct {
	// The unique identifier of the task.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Optional metadata associated with the request.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The ID of the push notification configuration to retrieve.
	PushNotificationConfigId *string `json:"pushNotificationConfigId,omitempty" yaml:"pushNotificationConfigId,omitempty" mapstructure:"pushNotificationConfigId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskPushNotificationConfigParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetTaskPushNotificationConfigParams: required")
	}
	type Plain GetTaskPushNotificationConfigParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskPushNotificationConfigParams(plain)
	return nil
}

// Represents a JSON-RPC request for the `tasks/pushNotificationConfig/get` method.
type GetTaskPushNotificationConfigRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'tasks/pushNotificationConfig/get'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameters for getting a push notification configuration.
	Params GetTaskPushNotificationConfigRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Defines parameters containing a task ID, used for simple task operations.
type GetTaskPushNotificationConfigRequestParams struct {
	// The unique identifier of the task.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Optional metadata associated with the request.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The ID of the push notification configuration to retrieve.
	PushNotificationConfigId *string `json:"pushNotificationConfigId,omitempty" yaml:"pushNotificationConfigId,omitempty" mapstructure:"pushNotificationConfigId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskPushNotificationConfigRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var getTaskPushNotificationConfigRequestParams_0 GetTaskPushNotificationConfigRequestParams_0
	var getTaskPushNotificationConfigRequestParams_1 GetTaskPushNotificationConfigRequestParams_1
	var errs []error
	if err := getTaskPushNotificationConfigRequestParams_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := getTaskPushNotificationConfigRequestParams_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 2 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain GetTaskPushNotificationConfigRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskPushNotificationConfigRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskPushNotificationConfigRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in GetTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in GetTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in GetTaskPushNotificationConfigRequest: required")
	}
	type Plain GetTaskPushNotificationConfigRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskPushNotificationConfigRequest(plain)
	return nil
}

// Represents a JSON-RPC response for the `tasks/pushNotificationConfig/get`
// method.
type GetTaskPushNotificationConfigResponse interface{}

// Represents a successful JSON-RPC response for the
// `tasks/pushNotificationConfig/get` method.
type GetTaskPushNotificationConfigSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The result, containing the requested push notification configuration.
	Result TaskPushNotificationConfig `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskPushNotificationConfigSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetTaskPushNotificationConfigSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in GetTaskPushNotificationConfigSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in GetTaskPushNotificationConfigSuccessResponse: required")
	}
	type Plain GetTaskPushNotificationConfigSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskPushNotificationConfigSuccessResponse(plain)
	return nil
}

// Represents a JSON-RPC request for the `tasks/get` method.
type GetTaskRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'tasks/get'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameters for querying a task.
	Params TaskQueryParams `json:"params" yaml:"params" mapstructure:"params"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetTaskRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in GetTaskRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in GetTaskRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in GetTaskRequest: required")
	}
	type Plain GetTaskRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskRequest(plain)
	return nil
}

// Represents a JSON-RPC response for the `tasks/get` method.
type GetTaskResponse interface{}

// Represents a successful JSON-RPC response for the `tasks/get` method.
type GetTaskSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The result, containing the requested Task object.
	Result Task `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetTaskSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in GetTaskSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in GetTaskSuccessResponse: required")
	}
	type Plain GetTaskSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskSuccessResponse(plain)
	return nil
}

// Defines a security scheme using HTTP authentication.
type HTTPAuthSecurityScheme struct {
	// A hint to the client to identify how the bearer token is formatted (e.g.,
	// "JWT").
	// This is primarily for documentation purposes.
	BearerFormat *string `json:"bearerFormat,omitempty" yaml:"bearerFormat,omitempty" mapstructure:"bearerFormat,omitempty"`

	// An optional description for the security scheme.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The name of the HTTP Authentication scheme to be used in the Authorization
	// header,
	// as defined in RFC7235 (e.g., "Bearer").
	// This value should be registered in the IANA Authentication Scheme registry.
	Scheme string `json:"scheme" yaml:"scheme" mapstructure:"scheme"`

	// The type of the security scheme. Must be 'http'.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HTTPAuthSecurityScheme) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["scheme"]; raw != nil && !ok {
		return fmt.Errorf("field scheme in HTTPAuthSecurityScheme: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in HTTPAuthSecurityScheme: required")
	}
	type Plain HTTPAuthSecurityScheme
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = HTTPAuthSecurityScheme(plain)
	return nil
}

// Defines configuration details for the OAuth 2.0 Implicit flow.
type ImplicitOAuthFlow struct {
	// The authorization URL to be used for this flow. This MUST be a URL.
	AuthorizationUrl string `json:"authorizationUrl" yaml:"authorizationUrl" mapstructure:"authorizationUrl"`

	// The URL to be used for obtaining refresh tokens. This MUST be a URL.
	RefreshUrl *string `json:"refreshUrl,omitempty" yaml:"refreshUrl,omitempty" mapstructure:"refreshUrl,omitempty"`

	// The available scopes for the OAuth2 security scheme. A map between the scope
	// name and a short description for it.
	Scopes map[string]string `json:"scopes" yaml:"scopes" mapstructure:"scopes"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplicitOAuthFlow) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["authorizationUrl"]; raw != nil && !ok {
		return fmt.Errorf("field authorizationUrl in ImplicitOAuthFlow: required")
	}
	if _, ok := raw["scopes"]; raw != nil && !ok {
		return fmt.Errorf("field scopes in ImplicitOAuthFlow: required")
	}
	type Plain ImplicitOAuthFlow
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImplicitOAuthFlow(plain)
	return nil
}

// An error indicating an internal error on the server.
type InternalError struct {
	// The error code for an internal server error.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InternalError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in InternalError: required")
	}
	type Plain InternalError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Internal error"
	}
	*j = InternalError(plain)
	return nil
}

// An A2A-specific error indicating that the agent returned a response that
// does not conform to the specification for the current method.
type InvalidAgentResponseError struct {
	// The error code for an invalid agent response.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InvalidAgentResponseError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in InvalidAgentResponseError: required")
	}
	type Plain InvalidAgentResponseError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Invalid agent response"
	}
	*j = InvalidAgentResponseError(plain)
	return nil
}

// An error indicating that the method parameters are invalid.
type InvalidParamsError struct {
	// The error code for an invalid parameters error.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InvalidParamsError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in InvalidParamsError: required")
	}
	type Plain InvalidParamsError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Invalid parameters"
	}
	*j = InvalidParamsError(plain)
	return nil
}

// An error indicating that the JSON sent is not a valid Request object.
type InvalidRequestError struct {
	// The error code for an invalid request.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InvalidRequestError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in InvalidRequestError: required")
	}
	type Plain InvalidRequestError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Request payload validation error"
	}
	*j = InvalidRequestError(plain)
	return nil
}

// An error indicating that the server received invalid JSON.
type JSONParseError struct {
	// The error code for a JSON parse error.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONParseError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in JSONParseError: required")
	}
	type Plain JSONParseError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Invalid JSON payload"
	}
	*j = JSONParseError(plain)
	return nil
}

// Represents a JSON-RPC 2.0 Error object, included in an error response.
type JSONRPCError struct {
	// A number that indicates the error type that occurred.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// A string providing a short description of the error.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// Represents a JSON-RPC 2.0 Error Response object.
type JSONRPCErrorResponse struct {
	// An object describing the error that occurred.
	Error JSONRPCErrorResponseError `json:"error" yaml:"error" mapstructure:"error"`

	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`
}

// Represents a JSON-RPC 2.0 Error object, included in an error response.
type JSONRPCErrorResponseError struct {
	// A number that indicates the error type that occurred.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// A string providing a short description of the error.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCErrorResponseError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var jSONRPCErrorResponseError_0 JSONRPCErrorResponseError_0
	var jSONRPCErrorResponseError_1 JSONRPCErrorResponseError_1
	var jSONRPCErrorResponseError_2 JSONRPCErrorResponseError_2
	var jSONRPCErrorResponseError_3 JSONRPCErrorResponseError_3
	var jSONRPCErrorResponseError_4 JSONRPCErrorResponseError_4
	var jSONRPCErrorResponseError_5 JSONRPCErrorResponseError_5
	var jSONRPCErrorResponseError_6 JSONRPCErrorResponseError_6
	var jSONRPCErrorResponseError_7 JSONRPCErrorResponseError_7
	var jSONRPCErrorResponseError_8 JSONRPCErrorResponseError_8
	var jSONRPCErrorResponseError_9 JSONRPCErrorResponseError_9
	var jSONRPCErrorResponseError_10 JSONRPCErrorResponseError_10
	var jSONRPCErrorResponseError_11 JSONRPCErrorResponseError_11
	var jSONRPCErrorResponseError_12 JSONRPCErrorResponseError_12
	var errs []error
	if err := jSONRPCErrorResponseError_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_2.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_3.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_4.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_5.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_6.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_7.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_8.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_9.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_10.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_11.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := jSONRPCErrorResponseError_12.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 13 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain JSONRPCErrorResponseError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCErrorResponseError(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCErrorResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["error"]; raw != nil && !ok {
		return fmt.Errorf("field error in JSONRPCErrorResponse: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in JSONRPCErrorResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in JSONRPCErrorResponse: required")
	}
	type Plain JSONRPCErrorResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCErrorResponse(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in JSONRPCError: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in JSONRPCError: required")
	}
	type Plain JSONRPCError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCError(plain)
	return nil
}

// Defines the base structure for any JSON-RPC 2.0 request, response, or
// notification.
type JSONRPCMessage struct {
	// A unique identifier established by the client. It must be a String, a Number,
	// or null.
	// The server must reply with the same value in the response. This property is
	// omitted for notifications.
	Id interface{} `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in JSONRPCMessage: required")
	}
	type Plain JSONRPCMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCMessage(plain)
	return nil
}

// Represents a JSON-RPC 2.0 Request object.
type JSONRPCRequest struct {
	// A unique identifier established by the client. It must be a String, a Number,
	// or null.
	// The server must reply with the same value in the response. This property is
	// omitted for notifications.
	Id interface{} `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// A string containing the name of the method to be invoked.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// A structured value holding the parameter values to be used during the method
	// invocation.
	Params map[string]interface{} `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in JSONRPCRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in JSONRPCRequest: required")
	}
	type Plain JSONRPCRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCRequest(plain)
	return nil
}

// A discriminated union representing all possible JSON-RPC 2.0 responses
// for the A2A specification methods.
type JSONRPCResponse interface{}

// Represents a successful JSON-RPC 2.0 Response object.
type JSONRPCSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The value of this member is determined by the method invoked on the Server.
	Result interface{} `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in JSONRPCSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in JSONRPCSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in JSONRPCSuccessResponse: required")
	}
	type Plain JSONRPCSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCSuccessResponse(plain)
	return nil
}

// Defines parameters for listing all push notification configurations associated
// with a task.
type ListTaskPushNotificationConfigParams struct {
	// The unique identifier of the task.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Optional metadata associated with the request.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListTaskPushNotificationConfigParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ListTaskPushNotificationConfigParams: required")
	}
	type Plain ListTaskPushNotificationConfigParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListTaskPushNotificationConfigParams(plain)
	return nil
}

// Represents a JSON-RPC request for the `tasks/pushNotificationConfig/list`
// method.
type ListTaskPushNotificationConfigRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'tasks/pushNotificationConfig/list'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameters identifying the task whose configurations are to be listed.
	Params ListTaskPushNotificationConfigParams `json:"params" yaml:"params" mapstructure:"params"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListTaskPushNotificationConfigRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ListTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ListTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ListTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in ListTaskPushNotificationConfigRequest: required")
	}
	type Plain ListTaskPushNotificationConfigRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListTaskPushNotificationConfigRequest(plain)
	return nil
}

// Represents a JSON-RPC response for the `tasks/pushNotificationConfig/list`
// method.
type ListTaskPushNotificationConfigResponse interface{}

// Represents a successful JSON-RPC response for the
// `tasks/pushNotificationConfig/list` method.
type ListTaskPushNotificationConfigSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The result, containing an array of all push notification configurations for the
	// task.
	Result []TaskPushNotificationConfig `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListTaskPushNotificationConfigSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ListTaskPushNotificationConfigSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ListTaskPushNotificationConfigSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in ListTaskPushNotificationConfigSuccessResponse: required")
	}
	type Plain ListTaskPushNotificationConfigSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListTaskPushNotificationConfigSuccessResponse(plain)
	return nil
}

// Represents a single message in the conversation between a user and an agent.
type Message struct {
	// The context identifier for this message, used to group related interactions.
	ContextId *string `json:"contextId,omitempty" yaml:"contextId,omitempty" mapstructure:"contextId,omitempty"`

	// The URIs of extensions that are relevant to this message.
	Extensions []string `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// The type of this object, used as a discriminator. Always 'message' for a
	// Message.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// A unique identifier for the message, typically a UUID, generated by the sender.
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`

	// Optional metadata for extensions. The key is an extension-specific identifier.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// An array of content parts that form the message body. A message can be
	// composed of multiple parts of different types (e.g., text and files).
	Parts []MessagePartsElem `json:"parts" yaml:"parts" mapstructure:"parts"`

	// A list of other task IDs that this message references for additional context.
	ReferenceTaskIds []string `json:"referenceTaskIds,omitempty" yaml:"referenceTaskIds,omitempty" mapstructure:"referenceTaskIds,omitempty"`

	// Identifies the sender of the message. `user` for the client, `agent` for the
	// service.
	Role MessageRole `json:"role" yaml:"role" mapstructure:"role"`

	// The identifier of the task this message is part of. Can be omitted for the
	// first message of a new task.
	TaskId *string `json:"taskId,omitempty" yaml:"taskId,omitempty" mapstructure:"taskId,omitempty"`
}

type MessagePartsElem interface{}

type MessageRole string

const MessageRoleAgent MessageRole = "agent"
const MessageRoleUser MessageRole = "user"

var enumValues_MessageRole = []interface{}{
	"agent",
	"user",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageRole) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MessageRole {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MessageRole, v)
	}
	*j = MessageRole(v)
	return nil
}

// Defines configuration options for a `message/send` or `message/stream` request.
type MessageSendConfiguration struct {
	// A list of output MIME types the client is prepared to accept in the response.
	AcceptedOutputModes []string `json:"acceptedOutputModes,omitempty" yaml:"acceptedOutputModes,omitempty" mapstructure:"acceptedOutputModes,omitempty"`

	// If true, the client will wait for the task to complete. The server may reject
	// this if the task is long-running.
	Blocking *bool `json:"blocking,omitempty" yaml:"blocking,omitempty" mapstructure:"blocking,omitempty"`

	// The number of most recent messages from the task's history to retrieve in the
	// response.
	HistoryLength *int `json:"historyLength,omitempty" yaml:"historyLength,omitempty" mapstructure:"historyLength,omitempty"`

	// Configuration for the agent to send push notifications for updates after the
	// initial response.
	PushNotificationConfig *PushNotificationConfig `json:"pushNotificationConfig,omitempty" yaml:"pushNotificationConfig,omitempty" mapstructure:"pushNotificationConfig,omitempty"`
}

// Defines the parameters for a request to send a message to an agent. This can be
// used
// to create a new task, continue an existing one, or restart a task.
type MessageSendParams struct {
	// Optional configuration for the send request.
	Configuration *MessageSendConfiguration `json:"configuration,omitempty" yaml:"configuration,omitempty" mapstructure:"configuration,omitempty"`

	// The message object being sent to the agent.
	Message Message `json:"message" yaml:"message" mapstructure:"message"`

	// Optional metadata for extensions.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageSendParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in MessageSendParams: required")
	}
	type Plain MessageSendParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MessageSendParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Message) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in Message: required")
	}
	if _, ok := raw["messageId"]; raw != nil && !ok {
		return fmt.Errorf("field messageId in Message: required")
	}
	if _, ok := raw["parts"]; raw != nil && !ok {
		return fmt.Errorf("field parts in Message: required")
	}
	if _, ok := raw["role"]; raw != nil && !ok {
		return fmt.Errorf("field role in Message: required")
	}
	type Plain Message
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Message(plain)
	return nil
}

// An error indicating that the requested method does not exist or is not
// available.
type MethodNotFoundError struct {
	// The error code for a method not found error.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MethodNotFoundError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in MethodNotFoundError: required")
	}
	type Plain MethodNotFoundError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Method not found"
	}
	*j = MethodNotFoundError(plain)
	return nil
}

// Defines a security scheme using mTLS authentication.
type MutualTLSSecurityScheme struct {
	// An optional description for the security scheme.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The type of the security scheme. Must be 'mutualTLS'.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MutualTLSSecurityScheme) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MutualTLSSecurityScheme: required")
	}
	type Plain MutualTLSSecurityScheme
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MutualTLSSecurityScheme(plain)
	return nil
}

// Defines a security scheme using OAuth 2.0.
type OAuth2SecurityScheme struct {
	// An optional description for the security scheme.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// An object containing configuration information for the supported OAuth 2.0
	// flows.
	Flows OAuthFlows `json:"flows" yaml:"flows" mapstructure:"flows"`

	// URL to the oauth2 authorization server metadata
	// [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
	Oauth2MetadataUrl *string `json:"oauth2MetadataUrl,omitempty" yaml:"oauth2MetadataUrl,omitempty" mapstructure:"oauth2MetadataUrl,omitempty"`

	// The type of the security scheme. Must be 'oauth2'.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OAuth2SecurityScheme) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["flows"]; raw != nil && !ok {
		return fmt.Errorf("field flows in OAuth2SecurityScheme: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in OAuth2SecurityScheme: required")
	}
	type Plain OAuth2SecurityScheme
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OAuth2SecurityScheme(plain)
	return nil
}

// Defines the configuration for the supported OAuth 2.0 flows.
type OAuthFlows struct {
	// Configuration for the OAuth Authorization Code flow. Previously called
	// accessCode in OpenAPI 2.0.
	AuthorizationCode *AuthorizationCodeOAuthFlow `json:"authorizationCode,omitempty" yaml:"authorizationCode,omitempty" mapstructure:"authorizationCode,omitempty"`

	// Configuration for the OAuth Client Credentials flow. Previously called
	// application in OpenAPI 2.0.
	ClientCredentials *ClientCredentialsOAuthFlow `json:"clientCredentials,omitempty" yaml:"clientCredentials,omitempty" mapstructure:"clientCredentials,omitempty"`

	// Configuration for the OAuth Implicit flow.
	Implicit *ImplicitOAuthFlow `json:"implicit,omitempty" yaml:"implicit,omitempty" mapstructure:"implicit,omitempty"`

	// Configuration for the OAuth Resource Owner Password flow.
	Password *PasswordOAuthFlow `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`
}

// Defines a security scheme using OpenID Connect.
type OpenIdConnectSecurityScheme struct {
	// An optional description for the security scheme.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The OpenID Connect Discovery URL for the OIDC provider's metadata.
	OpenIdConnectUrl string `json:"openIdConnectUrl" yaml:"openIdConnectUrl" mapstructure:"openIdConnectUrl"`

	// The type of the security scheme. Must be 'openIdConnect'.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenIdConnectSecurityScheme) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["openIdConnectUrl"]; raw != nil && !ok {
		return fmt.Errorf("field openIdConnectUrl in OpenIdConnectSecurityScheme: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in OpenIdConnectSecurityScheme: required")
	}
	type Plain OpenIdConnectSecurityScheme
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OpenIdConnectSecurityScheme(plain)
	return nil
}

// A discriminated union representing a part of a message or artifact, which can
// be text, a file, or structured data.
type Part interface{}

// Defines base properties common to all message or artifact parts.
type PartBase struct {
	// Optional metadata associated with this part.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Defines configuration details for the OAuth 2.0 Resource Owner Password flow.
type PasswordOAuthFlow struct {
	// The URL to be used for obtaining refresh tokens. This MUST be a URL.
	RefreshUrl *string `json:"refreshUrl,omitempty" yaml:"refreshUrl,omitempty" mapstructure:"refreshUrl,omitempty"`

	// The available scopes for the OAuth2 security scheme. A map between the scope
	// name and a short description for it.
	Scopes map[string]string `json:"scopes" yaml:"scopes" mapstructure:"scopes"`

	// The token URL to be used for this flow. This MUST be a URL.
	TokenUrl string `json:"tokenUrl" yaml:"tokenUrl" mapstructure:"tokenUrl"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PasswordOAuthFlow) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["scopes"]; raw != nil && !ok {
		return fmt.Errorf("field scopes in PasswordOAuthFlow: required")
	}
	if _, ok := raw["tokenUrl"]; raw != nil && !ok {
		return fmt.Errorf("field tokenUrl in PasswordOAuthFlow: required")
	}
	type Plain PasswordOAuthFlow
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PasswordOAuthFlow(plain)
	return nil
}

// Defines authentication details for a push notification endpoint.
type PushNotificationAuthenticationInfo struct {
	// Optional credentials required by the push notification endpoint.
	Credentials *string `json:"credentials,omitempty" yaml:"credentials,omitempty" mapstructure:"credentials,omitempty"`

	// A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
	Schemes []string `json:"schemes" yaml:"schemes" mapstructure:"schemes"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PushNotificationAuthenticationInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["schemes"]; raw != nil && !ok {
		return fmt.Errorf("field schemes in PushNotificationAuthenticationInfo: required")
	}
	type Plain PushNotificationAuthenticationInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PushNotificationAuthenticationInfo(plain)
	return nil
}

// Defines the configuration for setting up push notifications for task updates.
type PushNotificationConfig struct {
	// Optional authentication details for the agent to use when calling the
	// notification URL.
	Authentication *PushNotificationAuthenticationInfo `json:"authentication,omitempty" yaml:"authentication,omitempty" mapstructure:"authentication,omitempty"`

	// A unique ID for the push notification configuration, set by the client
	// to support multiple notification callbacks.
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// A unique token for this task or session to validate incoming push
	// notifications.
	Token *string `json:"token,omitempty" yaml:"token,omitempty" mapstructure:"token,omitempty"`

	// The callback URL where the agent should send push notifications.
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PushNotificationConfig) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in PushNotificationConfig: required")
	}
	type Plain PushNotificationConfig
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PushNotificationConfig(plain)
	return nil
}

// An A2A-specific error indicating that the agent does not support push
// notifications.
type PushNotificationNotSupportedError struct {
	// The error code for when push notifications are not supported.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PushNotificationNotSupportedError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in PushNotificationNotSupportedError: required")
	}
	type Plain PushNotificationNotSupportedError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Push Notification is not supported"
	}
	*j = PushNotificationNotSupportedError(plain)
	return nil
}

// Defines a security scheme that can be used to secure an agent's endpoints.
// This is a discriminated union type based on the OpenAPI 3.0 Security Scheme
// Object.
type SecurityScheme interface{}

// Defines base properties shared by all security scheme objects.
type SecuritySchemeBase struct {
	// An optional description for the security scheme.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`
}

// Represents a JSON-RPC request for the `message/send` method.
type SendMessageRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'message/send'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameters for sending a message.
	Params MessageSendParams `json:"params" yaml:"params" mapstructure:"params"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendMessageRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SendMessageRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in SendMessageRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in SendMessageRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in SendMessageRequest: required")
	}
	type Plain SendMessageRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SendMessageRequest(plain)
	return nil
}

// Represents a JSON-RPC response for the `message/send` method.
type SendMessageResponse interface{}

// Represents a successful JSON-RPC response for the `message/send` method.
type SendMessageSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The result, which can be a direct reply Message or the initial Task object.
	Result SendMessageSuccessResponseResult `json:"result" yaml:"result" mapstructure:"result"`
}

// Represents a single, stateful operation or conversation between a client and an
// agent.
type SendMessageSuccessResponseResult struct {
	// A collection of artifacts generated by the agent during the execution of the
	// task.
	Artifacts []Artifact `json:"artifacts,omitempty" yaml:"artifacts,omitempty" mapstructure:"artifacts,omitempty"`

	// A server-generated identifier for maintaining context across multiple related
	// tasks or interactions.
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`

	// The URIs of extensions that are relevant to this message.
	Extensions []string `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// An array of messages exchanged during the task, representing the conversation
	// history.
	History []Message `json:"history,omitempty" yaml:"history,omitempty" mapstructure:"history,omitempty"`

	// A unique identifier for the task, generated by the server for a new task.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The type of this object, used as a discriminator. Always 'task' for a Task.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// A unique identifier for the message, typically a UUID, generated by the sender.
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`

	// Optional metadata for extensions. The key is an extension-specific identifier.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// An array of content parts that form the message body. A message can be
	// composed of multiple parts of different types (e.g., text and files).
	Parts []MessagePartsElem `json:"parts" yaml:"parts" mapstructure:"parts"`

	// A list of other task IDs that this message references for additional context.
	ReferenceTaskIds []string `json:"referenceTaskIds,omitempty" yaml:"referenceTaskIds,omitempty" mapstructure:"referenceTaskIds,omitempty"`

	// Identifies the sender of the message. `user` for the client, `agent` for the
	// service.
	Role MessageRole `json:"role" yaml:"role" mapstructure:"role"`

	// The current status of the task, including its state and a descriptive message.
	Status TaskStatus `json:"status" yaml:"status" mapstructure:"status"`

	// The identifier of the task this message is part of. Can be omitted for the
	// first message of a new task.
	TaskId *string `json:"taskId,omitempty" yaml:"taskId,omitempty" mapstructure:"taskId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendMessageSuccessResponseResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var sendMessageSuccessResponseResult_0 SendMessageSuccessResponseResult_0
	var sendMessageSuccessResponseResult_1 SendMessageSuccessResponseResult_1
	var errs []error
	if err := sendMessageSuccessResponseResult_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := sendMessageSuccessResponseResult_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 2 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain SendMessageSuccessResponseResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SendMessageSuccessResponseResult(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendMessageSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SendMessageSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in SendMessageSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in SendMessageSuccessResponse: required")
	}
	type Plain SendMessageSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SendMessageSuccessResponse(plain)
	return nil
}

// Represents a JSON-RPC request for the `message/stream` method.
type SendStreamingMessageRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'message/stream'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameters for sending a message.
	Params MessageSendParams `json:"params" yaml:"params" mapstructure:"params"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendStreamingMessageRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SendStreamingMessageRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in SendStreamingMessageRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in SendStreamingMessageRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in SendStreamingMessageRequest: required")
	}
	type Plain SendStreamingMessageRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SendStreamingMessageRequest(plain)
	return nil
}

// Represents a JSON-RPC response for the `message/stream` method.
type SendStreamingMessageResponse interface{}

// Represents a successful JSON-RPC response for the `message/stream` method.
// The server may send multiple response objects for a single request.
type SendStreamingMessageSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The result, which can be a Message, Task, or a streaming update event.
	Result SendStreamingMessageSuccessResponseResult `json:"result" yaml:"result" mapstructure:"result"`
}

// Represents a single, stateful operation or conversation between a client and an
// agent.
type SendStreamingMessageSuccessResponseResult struct {
	// If true, the content of this artifact should be appended to a previously sent
	// artifact with the same ID.
	Append *bool `json:"append,omitempty" yaml:"append,omitempty" mapstructure:"append,omitempty"`

	// The artifact that was generated or updated.
	Artifact Artifact `json:"artifact" yaml:"artifact" mapstructure:"artifact"`

	// A collection of artifacts generated by the agent during the execution of the
	// task.
	Artifacts []Artifact `json:"artifacts,omitempty" yaml:"artifacts,omitempty" mapstructure:"artifacts,omitempty"`

	// A server-generated identifier for maintaining context across multiple related
	// tasks or interactions.
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`

	// The URIs of extensions that are relevant to this message.
	Extensions []string `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// If true, this is the final event in the stream for this interaction.
	Final bool `json:"final" yaml:"final" mapstructure:"final"`

	// An array of messages exchanged during the task, representing the conversation
	// history.
	History []Message `json:"history,omitempty" yaml:"history,omitempty" mapstructure:"history,omitempty"`

	// A unique identifier for the task, generated by the server for a new task.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The type of this object, used as a discriminator. Always 'task' for a Task.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// If true, this is the final chunk of the artifact.
	LastChunk *bool `json:"lastChunk,omitempty" yaml:"lastChunk,omitempty" mapstructure:"lastChunk,omitempty"`

	// A unique identifier for the message, typically a UUID, generated by the sender.
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`

	// Optional metadata for extensions. The key is an extension-specific identifier.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// An array of content parts that form the message body. A message can be
	// composed of multiple parts of different types (e.g., text and files).
	Parts []MessagePartsElem `json:"parts" yaml:"parts" mapstructure:"parts"`

	// A list of other task IDs that this message references for additional context.
	ReferenceTaskIds []string `json:"referenceTaskIds,omitempty" yaml:"referenceTaskIds,omitempty" mapstructure:"referenceTaskIds,omitempty"`

	// Identifies the sender of the message. `user` for the client, `agent` for the
	// service.
	Role MessageRole `json:"role" yaml:"role" mapstructure:"role"`

	// The current status of the task, including its state and a descriptive message.
	Status TaskStatus `json:"status" yaml:"status" mapstructure:"status"`

	// The identifier of the task this message is part of. Can be omitted for the
	// first message of a new task.
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendStreamingMessageSuccessResponseResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var sendStreamingMessageSuccessResponseResult_0 SendStreamingMessageSuccessResponseResult_0
	var sendStreamingMessageSuccessResponseResult_1 SendStreamingMessageSuccessResponseResult_1
	var sendStreamingMessageSuccessResponseResult_2 SendStreamingMessageSuccessResponseResult_2
	var sendStreamingMessageSuccessResponseResult_3 SendStreamingMessageSuccessResponseResult_3
	var errs []error
	if err := sendStreamingMessageSuccessResponseResult_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := sendStreamingMessageSuccessResponseResult_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := sendStreamingMessageSuccessResponseResult_2.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := sendStreamingMessageSuccessResponseResult_3.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 4 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain SendStreamingMessageSuccessResponseResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SendStreamingMessageSuccessResponseResult(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendStreamingMessageSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SendStreamingMessageSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in SendStreamingMessageSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in SendStreamingMessageSuccessResponse: required")
	}
	type Plain SendStreamingMessageSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SendStreamingMessageSuccessResponse(plain)
	return nil
}

// Represents a JSON-RPC request for the `tasks/pushNotificationConfig/set` method.
type SetTaskPushNotificationConfigRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'tasks/pushNotificationConfig/set'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameters for setting the push notification configuration.
	Params TaskPushNotificationConfig `json:"params" yaml:"params" mapstructure:"params"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetTaskPushNotificationConfigRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SetTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in SetTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in SetTaskPushNotificationConfigRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in SetTaskPushNotificationConfigRequest: required")
	}
	type Plain SetTaskPushNotificationConfigRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SetTaskPushNotificationConfigRequest(plain)
	return nil
}

// Represents a JSON-RPC response for the `tasks/pushNotificationConfig/set`
// method.
type SetTaskPushNotificationConfigResponse interface{}

// Represents a successful JSON-RPC response for the
// `tasks/pushNotificationConfig/set` method.
type SetTaskPushNotificationConfigSuccessResponse struct {
	// The identifier established by the client.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The result, containing the configured push notification settings.
	Result TaskPushNotificationConfig `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetTaskPushNotificationConfigSuccessResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SetTaskPushNotificationConfigSuccessResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in SetTaskPushNotificationConfigSuccessResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in SetTaskPushNotificationConfigSuccessResponse: required")
	}
	type Plain SetTaskPushNotificationConfigSuccessResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SetTaskPushNotificationConfigSuccessResponse(plain)
	return nil
}

// Represents a single, stateful operation or conversation between a client and an
// agent.
type Task struct {
	// A collection of artifacts generated by the agent during the execution of the
	// task.
	Artifacts []Artifact `json:"artifacts,omitempty" yaml:"artifacts,omitempty" mapstructure:"artifacts,omitempty"`

	// A server-generated identifier for maintaining context across multiple related
	// tasks or interactions.
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`

	// An array of messages exchanged during the task, representing the conversation
	// history.
	History []Message `json:"history,omitempty" yaml:"history,omitempty" mapstructure:"history,omitempty"`

	// A unique identifier for the task, generated by the server for a new task.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The type of this object, used as a discriminator. Always 'task' for a Task.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Optional metadata for extensions. The key is an extension-specific identifier.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The current status of the task, including its state and a descriptive message.
	Status TaskStatus `json:"status" yaml:"status" mapstructure:"status"`
}

// An event sent by the agent to notify the client that an artifact has been
// generated or updated. This is typically used in streaming models.
type TaskArtifactUpdateEvent struct {
	// If true, the content of this artifact should be appended to a previously sent
	// artifact with the same ID.
	Append *bool `json:"append,omitempty" yaml:"append,omitempty" mapstructure:"append,omitempty"`

	// The artifact that was generated or updated.
	Artifact Artifact `json:"artifact" yaml:"artifact" mapstructure:"artifact"`

	// The context ID associated with the task.
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`

	// The type of this event, used as a discriminator. Always 'artifact-update'.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// If true, this is the final chunk of the artifact.
	LastChunk *bool `json:"lastChunk,omitempty" yaml:"lastChunk,omitempty" mapstructure:"lastChunk,omitempty"`

	// Optional metadata for extensions.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The ID of the task this artifact belongs to.
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskArtifactUpdateEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["artifact"]; raw != nil && !ok {
		return fmt.Errorf("field artifact in TaskArtifactUpdateEvent: required")
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in TaskArtifactUpdateEvent: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in TaskArtifactUpdateEvent: required")
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in TaskArtifactUpdateEvent: required")
	}
	type Plain TaskArtifactUpdateEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TaskArtifactUpdateEvent(plain)
	return nil
}

// Defines parameters containing a task ID, used for simple task operations.
type TaskIdParams struct {
	// The unique identifier of the task.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Optional metadata associated with the request.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskIdParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in TaskIdParams: required")
	}
	type Plain TaskIdParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TaskIdParams(plain)
	return nil
}

// An A2A-specific error indicating that the task is in a state where it cannot be
// canceled.
type TaskNotCancelableError struct {
	// The error code for a task that cannot be canceled.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskNotCancelableError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in TaskNotCancelableError: required")
	}
	type Plain TaskNotCancelableError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Task cannot be canceled"
	}
	*j = TaskNotCancelableError(plain)
	return nil
}

// An A2A-specific error indicating that the requested task ID was not found.
type TaskNotFoundError struct {
	// The error code for a task not found error.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskNotFoundError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in TaskNotFoundError: required")
	}
	type Plain TaskNotFoundError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "Task not found"
	}
	*j = TaskNotFoundError(plain)
	return nil
}

// A container associating a push notification configuration with a specific task.
type TaskPushNotificationConfig struct {
	// The push notification configuration for this task.
	PushNotificationConfig PushNotificationConfig `json:"pushNotificationConfig" yaml:"pushNotificationConfig" mapstructure:"pushNotificationConfig"`

	// The ID of the task.
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskPushNotificationConfig) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["pushNotificationConfig"]; raw != nil && !ok {
		return fmt.Errorf("field pushNotificationConfig in TaskPushNotificationConfig: required")
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in TaskPushNotificationConfig: required")
	}
	type Plain TaskPushNotificationConfig
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TaskPushNotificationConfig(plain)
	return nil
}

// Defines parameters for querying a task, with an option to limit history length.
type TaskQueryParams struct {
	// The number of most recent messages from the task's history to retrieve.
	HistoryLength *int `json:"historyLength,omitempty" yaml:"historyLength,omitempty" mapstructure:"historyLength,omitempty"`

	// The unique identifier of the task.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Optional metadata associated with the request.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskQueryParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in TaskQueryParams: required")
	}
	type Plain TaskQueryParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TaskQueryParams(plain)
	return nil
}

// Represents a JSON-RPC request for the `tasks/resubscribe` method, used to resume
// a streaming connection.
type TaskResubscriptionRequest struct {
	// The identifier for this request.
	Id interface{} `json:"id" yaml:"id" mapstructure:"id"`

	// The version of the JSON-RPC protocol. MUST be exactly "2.0".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// The method name. Must be 'tasks/resubscribe'.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameters identifying the task to resubscribe to.
	Params TaskIdParams `json:"params" yaml:"params" mapstructure:"params"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskResubscriptionRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in TaskResubscriptionRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in TaskResubscriptionRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in TaskResubscriptionRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in TaskResubscriptionRequest: required")
	}
	type Plain TaskResubscriptionRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TaskResubscriptionRequest(plain)
	return nil
}

type TaskState string

const TaskStateAuthRequired TaskState = "auth-required"
const TaskStateCanceled TaskState = "canceled"
const TaskStateCompleted TaskState = "completed"
const TaskStateFailed TaskState = "failed"
const TaskStateInputRequired TaskState = "input-required"
const TaskStateRejected TaskState = "rejected"
const TaskStateSubmitted TaskState = "submitted"
const TaskStateUnknown TaskState = "unknown"
const TaskStateWorking TaskState = "working"

var enumValues_TaskState = []interface{}{
	"submitted",
	"working",
	"input-required",
	"completed",
	"canceled",
	"failed",
	"rejected",
	"auth-required",
	"unknown",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskState) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TaskState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TaskState, v)
	}
	*j = TaskState(v)
	return nil
}

// Represents the status of a task at a specific point in time.
type TaskStatus struct {
	// An optional, human-readable message providing more details about the current
	// status.
	Message *Message `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// The current state of the task's lifecycle.
	State TaskState `json:"state" yaml:"state" mapstructure:"state"`

	// An ISO 8601 datetime string indicating when this status was recorded.
	Timestamp *string `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`
}

// An event sent by the agent to notify the client of a change in a task's status.
// This is typically used in streaming or subscription models.
type TaskStatusUpdateEvent struct {
	// The context ID associated with the task.
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`

	// If true, this is the final event in the stream for this interaction.
	Final bool `json:"final" yaml:"final" mapstructure:"final"`

	// The type of this event, used as a discriminator. Always 'status-update'.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Optional metadata for extensions.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The new status of the task.
	Status TaskStatus `json:"status" yaml:"status" mapstructure:"status"`

	// The ID of the task that was updated.
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskStatusUpdateEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in TaskStatusUpdateEvent: required")
	}
	if _, ok := raw["final"]; raw != nil && !ok {
		return fmt.Errorf("field final in TaskStatusUpdateEvent: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in TaskStatusUpdateEvent: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in TaskStatusUpdateEvent: required")
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in TaskStatusUpdateEvent: required")
	}
	type Plain TaskStatusUpdateEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TaskStatusUpdateEvent(plain)
	return nil
}

type JSONRPCErrorResponseError_9 = UnsupportedOperationError
type SendMessageSuccessResponseResult_0 = Task

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnsupportedOperationError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in UnsupportedOperationError: required")
	}
	type Plain UnsupportedOperationError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["message"]; !ok || v == nil {
		plain.Message = "This operation is not supported"
	}
	*j = UnsupportedOperationError(plain)
	return nil
}

// An A2A-specific error indicating that the requested operation is not supported
// by the agent.
type UnsupportedOperationError struct {
	// The error code for an unsupported operation.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// A primitive or structured value containing additional information about the
	// error.
	// This may be omitted.
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// The error message.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

type JSONRPCErrorResponseError_0 = JSONRPCError
type GetTaskPushNotificationConfigRequestParams_1 = GetTaskPushNotificationConfigParams
type GetTaskPushNotificationConfigRequestParams_0 = TaskIdParams
type JSONRPCErrorResponseError_12 = AuthenticatedExtendedCardNotConfiguredError
type FilePartFile_1 = FileWithUri
type FilePartFile_0 = FileWithBytes
type JSONRPCErrorResponseError_11 = InvalidAgentResponseError
type JSONRPCErrorResponseError_10 = ContentTypeNotSupportedError
type SendStreamingMessageSuccessResponseResult_0 = Task
type SendStreamingMessageSuccessResponseResult_1 = Message
type SendStreamingMessageSuccessResponseResult_2 = TaskStatusUpdateEvent
type SendStreamingMessageSuccessResponseResult_3 = TaskArtifactUpdateEvent
type SendMessageSuccessResponseResult_1 = Message
type JSONRPCErrorResponseError_8 = PushNotificationNotSupportedError
type JSONRPCErrorResponseError_7 = TaskNotCancelableError
type JSONRPCErrorResponseError_6 = TaskNotFoundError
type JSONRPCErrorResponseError_5 = InternalError
type JSONRPCErrorResponseError_4 = InvalidParamsError
type JSONRPCErrorResponseError_3 = MethodNotFoundError
type JSONRPCErrorResponseError_2 = InvalidRequestError
type JSONRPCErrorResponseError_1 = JSONParseError

// UnmarshalJSON implements json.Unmarshaler.
func (j *Task) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in Task: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Task: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in Task: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in Task: required")
	}
	type Plain Task
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Task(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskStatus) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["state"]; raw != nil && !ok {
		return fmt.Errorf("field state in TaskStatus: required")
	}
	type Plain TaskStatus
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TaskStatus(plain)
	return nil
}

// Represents a text segment within a message or artifact.
type TextPart struct {
	// The type of this part, used as a discriminator. Always 'text'.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Optional metadata associated with this part.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The string content of the text part.
	Text string `json:"text" yaml:"text" mapstructure:"text"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TextPart) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in TextPart: required")
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in TextPart: required")
	}
	type Plain TextPart
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TextPart(plain)
	return nil
}

type TransportProtocol string

var enumValues_TransportProtocol = []interface{}{
	"JSONRPC",
	"GRPC",
	"HTTP+JSON",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransportProtocol) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransportProtocol {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransportProtocol, v)
	}
	*j = TransportProtocol(v)
	return nil
}

const TransportProtocolJSONRPC TransportProtocol = "JSONRPC"
const TransportProtocolGRPC TransportProtocol = "GRPC"
const TransportProtocolHTTPJSON TransportProtocol = "HTTP+JSON"
